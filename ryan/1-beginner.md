## 서론 - 책 읽기 목적

1. 리액트적으로 사고하는 법 습득
2. 리액트 코드를 왜 이렇게 적어야 하는지 알기

## 입문자를 위한 지식

### 리액트가 필요한 이유

대규모로 즉각 업데이트를 하면서도, 성능/신뢰성/보안을 지키기 위해. 예를 들어, 좋아요 버튼 하나만 하더라도 다뤄야 할 상태가 많다(liked/pending/failed). 이러한 상태를 업데이트하는 로직을 관리하는 게 쉽지 않음. 리액트에서는 이를 선언적으로 유지보수에 유리하면서도 성능 좋게 관리할 수 있음.

즉, 상호작용 그에 따른 상태 업데이트를 구현하되 유지보수 및 성능 측면에서 유리하게 코드를 작성하기 위해 리액트를 사용.

### 양방향 데이터 흐름 vs 단방향 데이터 흐름

양방향: 뷰 단에서 직접 데이터(모델)를 건드릴 수 있다. 복잡성이 높아지고, 디버깅이 어려워짐.

단방향: useState로 데이터를 불러옴 -> 데이터를 jsx에 부착(바인딩)을 함 -> 상태를 변경하려면 setter를 사용해야 함(디스패처)

디버깅 시에 핸들러가 있는 곳만 살피면 된다.

### MVC?

- 골자: 웹 앱을 통으로 관리하지 말고 M, V, C 관심사를 분리해서 유지보수하기 좋게 관리하자.
- 주로 풀스택 웹 애플리케이션에서 활용됨.
- Model은 쉽게 말해 DB 데이터나 상태
- 비즈니스 로직은 모델과 컨트롤러에 둘 다 존재할 수 있다. -> 이 부분이 모호하긴 함.
- controller는 로직을 받아서, model은 데이터, view는 최종 보여지는 결과물 -> 이런 식으로 분류하면(사고하면) MVC인 거다.

### MVVM

- MVC에서 이제 즉각적으로 상태 변경이 화면에 반영될 필요성 및 프로그램이 대규모로 커지면서 개선의 필요성이 대두됨.
- 이를 위해 View Model을 만들어서 모델이 수정될 때 뷰에 자동적으로 반영될 수 있도록 함.
- 양방향 데이터

### 리액트

- 선언형: 무엇을 완료하고 싶은지 기술하면, 어떻게 이룰지는 리액트가 담당한다. `getElementById()` 등을 통해 실제 DOM 엘리먼트를 가져올 필요도 없음.
- 가상 DOM: 성능도 담당한다
- 컴포넌트 모델: 여러 조각으로 나눔. 컴포넌트 단위로 생각하기를 적극 권장. 이는 재사용성, 관심사 분리, 응집성 측면에서 유리
- 불변성: 상태 변경 시 원래 상태를 직접 변경하지 않고 새 상태 객체를 반환하는 방식. 변경 사항 추적, 디버깅에 유리.
- 생태계: 생태계가 잘 조성되어 활용할 수 있는 라이브러리, 도구가 많음.

---

MVVM

- View Model: 뷰모델은 모델로부터 데이터를 받아오고, 이것을
- store가 있고, vm이 이 store의 정적인 데이터를 즉시 반영될 수 있게 되는 것.
- 즉각적인 업데이트가 필요해져서
